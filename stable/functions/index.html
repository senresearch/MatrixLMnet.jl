<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Functions · MatrixLMnet</title><meta name="title" content="Types and Functions · MatrixLMnet"/><meta property="og:title" content="Types and Functions · MatrixLMnet"/><meta property="twitter:title" content="Types and Functions · MatrixLMnet"/><meta name="description" content="Documentation for MatrixLMnet."/><meta property="og:description" content="Documentation for MatrixLMnet."/><meta property="twitter:description" content="Documentation for MatrixLMnet."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MatrixLMnet</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../MLMnet_Simulation/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Types and Functions</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Description"><span>Description</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types and Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/senresearch/MatrixLMnet.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/senresearch/MatrixLMnet.jl/blob/main/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#MatrixLMnet.Mlmnet_bic"><code>MatrixLMnet.Mlmnet_bic</code></a></li><li><a href="#MatrixLMnet.Mlmnet_cv"><code>MatrixLMnet.Mlmnet_cv</code></a></li><li><a href="#MatrixLMnet.admm!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any, Vararg{AbstractMatrix{Float64}, 4}}"><code>MatrixLMnet.admm!</code></a></li><li><a href="#MatrixLMnet.backtransform!-Tuple{AbstractArray{Float64, 4}, Bool, Bool, Vararg{AbstractMatrix{Float64}, 4}}"><code>MatrixLMnet.backtransform!</code></a></li><li><a href="#MatrixLMnet.calc_avg_mse-Tuple{Mlmnet_cv}"><code>MatrixLMnet.calc_avg_mse</code></a></li><li><a href="#MatrixLMnet.calc_avg_prop_zero-Tuple{Mlmnet_cv}"><code>MatrixLMnet.calc_avg_prop_zero</code></a></li><li><a href="#MatrixLMnet.calc_bic-Tuple{Mlmnet}"><code>MatrixLMnet.calc_bic</code></a></li><li><a href="#MatrixLMnet.calc_grad-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}}"><code>MatrixLMnet.calc_grad</code></a></li><li><a href="#MatrixLMnet.calc_grad!-NTuple{4, AbstractMatrix{Float64}}"><code>MatrixLMnet.calc_grad!</code></a></li><li><a href="#MatrixLMnet.calc_mse-Tuple{AbstractVector{Mlmnet}, RawData, AbstractVector{Float64}, AbstractVector{Float64}, Vector{Vector{Int64}}, Vector{Vector{Int64}}}"><code>MatrixLMnet.calc_mse</code></a></li><li><a href="#MatrixLMnet.calc_mse-Tuple{Mlmnet}"><code>MatrixLMnet.calc_mse</code></a></li><li><a href="#MatrixLMnet.calc_prop_zero-Tuple{AbstractVector{Mlmnet}, AbstractVector{Float64}, AbstractVector{Float64}}"><code>MatrixLMnet.calc_prop_zero</code></a></li><li><a href="#MatrixLMnet.calc_prop_zero-Tuple{Mlmnet}"><code>MatrixLMnet.calc_prop_zero</code></a></li><li><a href="#MatrixLMnet.cd!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.cd!</code></a></li><li><a href="#MatrixLMnet.cd_active!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.cd_active!</code></a></li><li><a href="#MatrixLMnet.coef-Tuple{Mlmnet}"><code>MatrixLMnet.coef</code></a></li><li><a href="#MatrixLMnet.coef-Tuple{Mlmnet, Float64, Float64}"><code>MatrixLMnet.coef</code></a></li><li><a href="#MatrixLMnet.coef_3d-Tuple{Mlmnet}"><code>MatrixLMnet.coef_3d</code></a></li><li><a href="#MatrixLMnet.criterion-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractVector{Int64}}"><code>MatrixLMnet.criterion</code></a></li><li><a href="#MatrixLMnet.findnotin-Tuple{AbstractVector{Int64}, AbstractVector{Int64}}"><code>MatrixLMnet.findnotin</code></a></li><li><a href="#MatrixLMnet.fista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.fista!</code></a></li><li><a href="#MatrixLMnet.fista_bt!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.fista_bt!</code></a></li><li><a href="#MatrixLMnet.fitted-Tuple{Mlmnet}"><code>MatrixLMnet.fitted</code></a></li><li><a href="#MatrixLMnet.fitted-Tuple{Mlmnet, Float64, Float64}"><code>MatrixLMnet.fitted</code></a></li><li><a href="#MatrixLMnet.get_func-Tuple{String}"><code>MatrixLMnet.get_func</code></a></li><li><a href="#MatrixLMnet.inner_update_cd!-Tuple{Int64, Int64, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, BitMatrix}"><code>MatrixLMnet.inner_update_cd!</code></a></li><li><a href="#MatrixLMnet.inner_update_cd!-Tuple{Int64, Int64, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, BitMatrix}"><code>MatrixLMnet.inner_update_cd!</code></a></li><li><a href="#MatrixLMnet.ista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.ista!</code></a></li><li><a href="#MatrixLMnet.lambda_min-Tuple{Mlmnet_cv}"><code>MatrixLMnet.lambda_min</code></a></li><li><a href="#MatrixLMnet.make_folds"><code>MatrixLMnet.make_folds</code></a></li><li><a href="#MatrixLMnet.make_folds_conds"><code>MatrixLMnet.make_folds_conds</code></a></li><li><a href="#MatrixLMnet.minimize_rows-Tuple{Vector{CartesianIndex{2}}}"><code>MatrixLMnet.minimize_rows</code></a></li><li><a href="#MatrixLMnet.mlmnet-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}}"><code>MatrixLMnet.mlmnet</code></a></li><li><a href="#MatrixLMnet.mlmnet_bic-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}}"><code>MatrixLMnet.mlmnet_bic</code></a></li><li><a href="#MatrixLMnet.mlmnet_bic_summary-Tuple{Mlmnet_bic}"><code>MatrixLMnet.mlmnet_bic_summary</code></a></li><li><a href="#MatrixLMnet.mlmnet_cv-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}, Vector{Vector{Int64}}, Vector{Vector{Int64}}}"><code>MatrixLMnet.mlmnet_cv</code></a></li><li><a href="#MatrixLMnet.mlmnet_cv_summary-Tuple{Mlmnet_cv}"><code>MatrixLMnet.mlmnet_cv_summary</code></a></li><li><a href="#MatrixLMnet.mlmnet_pathwise-Tuple{Function, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.mlmnet_pathwise</code></a></li><li><a href="#MatrixLMnet.mlmnet_perms-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}}"><code>MatrixLMnet.mlmnet_perms</code></a></li><li><a href="#MatrixLMnet.normalize!-Tuple{AbstractMatrix{Float64}, Bool}"><code>MatrixLMnet.normalize!</code></a></li><li><a href="#MatrixLMnet.outer_update_fista_bt!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, Float64, BitMatrix, AbstractVector{Int64}, AbstractVector{Float64}, Float64}"><code>MatrixLMnet.outer_update_fista_bt!</code></a></li><li><a href="#MatrixLMnet.predict"><code>MatrixLMnet.predict</code></a></li><li><a href="#MatrixLMnet.predict"><code>MatrixLMnet.predict</code></a></li><li><a href="#MatrixLMnet.println_verbose"><code>MatrixLMnet.println_verbose</code></a></li><li><a href="#MatrixLMnet.prox-NTuple{6, Float64}"><code>MatrixLMnet.prox</code></a></li><li><a href="#MatrixLMnet.prox-NTuple{5, Float64}"><code>MatrixLMnet.prox</code></a></li><li><a href="#MatrixLMnet.prox-Tuple{Float64, Float64, Float64, Float64, Nothing, Float64}"><code>MatrixLMnet.prox</code></a></li><li><a href="#MatrixLMnet.prox-Tuple{Float64, Float64, Float64, Float64, Nothing}"><code>MatrixLMnet.prox</code></a></li><li><a href="#MatrixLMnet.prox_mat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, AbstractMatrix{Float64}}"><code>MatrixLMnet.prox_mat</code></a></li><li><a href="#MatrixLMnet.prox_mat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Nothing, Float64}"><code>MatrixLMnet.prox_mat</code></a></li><li><a href="#MatrixLMnet.prox_mat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, AbstractMatrix{Float64}, Float64}"><code>MatrixLMnet.prox_mat</code></a></li><li><a href="#MatrixLMnet.resid"><code>MatrixLMnet.resid</code></a></li><li><a href="#MatrixLMnet.resid"><code>MatrixLMnet.resid</code></a></li><li><a href="#MatrixLMnet.update_admm!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractVector{Int64}, AbstractVector{Int64}, AbstractVector{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, Float64}"><code>MatrixLMnet.update_admm!</code></a></li><li><a href="#MatrixLMnet.update_cd_active_cyclic!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}}"><code>MatrixLMnet.update_cd_active_cyclic!</code></a></li><li><a href="#MatrixLMnet.update_cd_active_random!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}}"><code>MatrixLMnet.update_cd_active_random!</code></a></li><li><a href="#MatrixLMnet.update_cd_cyclic!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix}"><code>MatrixLMnet.update_cd_cyclic!</code></a></li><li><a href="#MatrixLMnet.update_cd_random!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix}"><code>MatrixLMnet.update_cd_random!</code></a></li><li><a href="#MatrixLMnet.update_fista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, BitMatrix, AbstractVector{Int64}, AbstractVector{Float64}}"><code>MatrixLMnet.update_fista!</code></a></li><li><a href="#MatrixLMnet.update_fista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, Float64, BitMatrix, AbstractVector{Int64}, AbstractVector{Float64}}"><code>MatrixLMnet.update_fista!</code></a></li><li><a href="#MatrixLMnet.update_fista2!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, Float64, BitMatrix, AbstractVector{Float64}}"><code>MatrixLMnet.update_fista2!</code></a></li><li><a href="#MatrixLMnet.update_fista2!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, BitMatrix, AbstractVector{Float64}}"><code>MatrixLMnet.update_fista2!</code></a></li><li><a href="#MatrixLMnet.update_ista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, BitMatrix, AbstractVector{Float64}}"><code>MatrixLMnet.update_ista!</code></a></li><li><a href="#MatrixLMnet.update_ista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, Float64, BitMatrix, AbstractVector{Float64}}"><code>MatrixLMnet.update_ista!</code></a></li><li><a href="#MatrixLMnet.valid_reduce2"><code>MatrixLMnet.valid_reduce2</code></a></li></ul><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.Mlmnet_bic" href="#MatrixLMnet.Mlmnet_bic"><code>MatrixLMnet.Mlmnet_bic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Mlmnet_bic(MLMNet, lambdas, alphas, data)</code></pre><p>Type for storing the results of running BIC validation for <code>mlmnet</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/bic/mlmnet_bic.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.Mlmnet_cv" href="#MatrixLMnet.Mlmnet_cv"><code>MatrixLMnet.Mlmnet_cv</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Mlmnet_cv(MLMNets::Array{Mlmnet,1} , lambdas::Array{Float64,1}, alphas::Array{Float64,1}, data::RawData, rowFolds::Array{Array,1} , colFolds::Array{Array,1} )</code></pre><p>Type for storing the results of running cross-validation for <code>mlmnet</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.admm!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any, Vararg{AbstractMatrix{Float64}, 4}}" href="#MatrixLMnet.admm!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any, Vararg{AbstractMatrix{Float64}, 4}}"><code>MatrixLMnet.admm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">admm!(X::AbstractArray{Float64,2}, Y::AbstractArray{Float64,2}, 
           Z::AbstractArray{Float64,2}, lambda::Float64, alpha::Float64,
           B::AbstractArray{Float64,2}, 
           regXidx::AbstractArray{Int64,1}, 
           regZidx::AbstractArray{Int64,1}, reg::BitArray{2}, norms, 
           Qx::AbstractArray{Float64,2}, Qz::AbstractArray{Float64,2}, 
           U::AbstractArray{Float64,2}, L::AbstractArray{Float64,2}; 
           isVerbose::Bool=true, stepsize::Float64=0.01, 
           rho::Float64=1.0, setRho::Bool=true, 
           thresh::Float64=10.0^(-7), maxiter::Int=10^10, 
           tau_incr::Float64=2.0, tau_decr::Float64=2.0, mu::Float64=10.0)</code></pre><p>Performs ADMM. </p><p><strong>Arguments</strong></p><ul><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>lambda = lambda penalty, a floating scalar</li><li>alpha = parameter (ϵ[0, 1]) determining the mix of penalties between L1 and L2</li><li>B = 2d array of floats consisting of starting coefficient estimates</li><li>regXidx = 1d array of indices corresponding to regularized X covariates</li><li>regZidx = 1d array of indices corresponding to regularized Z covariates</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li><li>Qx = 2d array of floats consisting of the eigenvectors of X</li><li>Qz = 2d array of floats consisting of the eigenvectors of Z</li><li>U = 2d array of floats consisting of the transformed Y matrix</li><li>L = 2d array of floats consisting of the kronecker product of the  eigenvalues of X and Z</li></ul><p><strong>Keyword arguments</strong></p><ul><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>stepsize = float; step size for updates (irrelevant for ADMM).  Defaults to <code>0.01</code>. </li><li>rho = float; parameter that controls ADMM tuning. Defaults to <code>1.0</code>. </li><li>setRho = boolean flag indicating whether the ADMM tuning parameter <code>rho</code>  should be calculated. Defaults to <code>true</code>.</li><li>thresh = threshold at which the coefficients are considered to have  converged, a floating scalar. Defaults to <code>10^(-7)</code>. </li><li>maxiter = maximum number of update iterations. Defaults to <code>10^10</code>. </li><li>tau_incr = float; parameter that controls the factor at which rho increases.  Defaults to 2.0. </li><li>tau_decr = float; parameter that controls the factor at which rho decreases.  Defaults to 2.0. </li><li>mu = float; parameter that controls the factor at which the primal and dual  residuals should be within each other. Defaults to 10.0. </li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p><p><strong>Some notes</strong></p><p>Convergence is determined as when the log ratio of the current and previous  criteria is less than the threshold <code>thresh</code>. </p><p><code>rho</code> controls ADMM tuning and can be specified by the user. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/admm.jl#L169-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.backtransform!-Tuple{AbstractArray{Float64, 4}, Bool, Bool, Vararg{AbstractMatrix{Float64}, 4}}" href="#MatrixLMnet.backtransform!-Tuple{AbstractArray{Float64, 4}, Bool, Bool, Vararg{AbstractMatrix{Float64}, 4}}"><code>MatrixLMnet.backtransform!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">backtransform!(B::AbstractArray{Float64,4}, 
                    addXIntercept::Bool, addZIntercept::Bool, 
                    meansX::AbstractArray{Float64,2}, 
                    meansZ::AbstractArray{Float64,2}, 
                    normsX::AbstractArray{Float64,2}, 
                    normsZ::AbstractArray{Float64,2})</code></pre><p>Back-transform coefficient estimates B in place if X and Z were standardized  prior to the estimation– when not including intercept columns for either X  or Z. </p><p><strong>Arguments</strong></p><ul><li>B = 4d array of coefficient estimates</li><li>addXIntercept = boolean flag indicating whether or not to X has an  intercept column</li><li>addZIntercept = boolean flag indicating whether or not to Z has an  intercept column</li><li>meansX = 2d array of column means of X, obtained prior to standardizing X</li><li>meansZ = 2d array of column means of Z, obtained prior to standardizing Z</li><li>normsX = 2d array of column norms of X, obtained prior to standardizing X</li><li>normsZ = 2d array of column norms of Z, obtained prior to standardizing Z</li></ul><p><strong>Value</strong></p><p>None; back-transforms B in place. </p><p><strong>Some notes</strong></p><p>B is a 4d array in which each coefficient matrix is stored along the third and fourth  dimension. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/std_helpers.jl#L39-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.calc_avg_mse-Tuple{Mlmnet_cv}" href="#MatrixLMnet.calc_avg_mse-Tuple{Mlmnet_cv}"><code>MatrixLMnet.calc_avg_mse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_avg_mse(MLMNet_cv::Mlmnet_cv)</code></pre><p>Calculates average test MSE across folds. </p><p><strong>Arguments</strong></p><ul><li>MLMNet<em>cv = MLMNet</em>cv object</li></ul><p><strong>Value</strong></p><p>2d array of floats</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_summary.jl#L30-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.calc_avg_prop_zero-Tuple{Mlmnet_cv}" href="#MatrixLMnet.calc_avg_prop_zero-Tuple{Mlmnet_cv}"><code>MatrixLMnet.calc_avg_prop_zero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_avg_prop_zero(MLMNet_cv::Mlmnet_cv)</code></pre><p>Calculates average proportion of zero interaction coefficients across folds. </p><p><strong>Arguments</strong></p><ul><li>MLMNet<em>cv = MLMNet</em>cv object</li></ul><p><strong>Value</strong></p><p>1d array of floats</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_summary.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.calc_bic-Tuple{Mlmnet}" href="#MatrixLMnet.calc_bic-Tuple{Mlmnet}"><code>MatrixLMnet.calc_bic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>calc_bic(MLMNet::Mlmnet)</p><p>Calculates BIC for each model according to the lambda-alpha  pair parameter. </p><p><strong>Arguments</strong></p><ul><li>MLMNets = Mlmnet object resulting from <code>mlmnet()</code> function.</li></ul><p><strong>Value</strong></p><p>2d array of floats with dimensions equal to the number of lambdas by the  number of alphas. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/bic/mlmnet_bic_helpers.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.calc_grad!-NTuple{4, AbstractMatrix{Float64}}" href="#MatrixLMnet.calc_grad!-NTuple{4, AbstractMatrix{Float64}}"><code>MatrixLMnet.calc_grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_grad!(grad::AbstractArray{Float64,2}, 
                X::AbstractArray{Float64,2}, 
                Z::AbstractArray{Float64,2}, 
                resid::AbstractArray{Float64,2})</code></pre><p>Calculate gradient in place</p><p><strong>Arguments</strong></p><ul><li>gradient = 2d array of floats consisting of the gradient, to be updated in  place</li><li>X = 2d array of floats consisting of the row covariates, standardized as  necessary</li><li>Z = 2d array of floats consisting of the column covariates, standardized  as necessary</li><li>resid = 2d array of floats consisting of the residuals</li></ul><p><strong>Value</strong></p><p>None; updates gradient in place. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L247-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.calc_grad-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}}" href="#MatrixLMnet.calc_grad-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}}"><code>MatrixLMnet.calc_grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_grad!(Xi::AbstractArray{Float64,1}, Zj::AbstractArray{Float64,1}, 
               resid::AbstractArray{Float64,2})</code></pre><p>Calculate gradient at a single coefficient</p><p><strong>Arguments</strong></p><ul><li>Xi = 1d array of floats consisting of the row covariates for the  coefficient, standardized as necessary</li><li>Zj = 1d array of floats consisting of the column covariates for the  coefficient, standardized as necessary</li><li>resid = 2d array of floats consisting of the residuals</li></ul><p><strong>Value</strong></p><p>A floating scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L279-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.calc_mse-Tuple{AbstractVector{Mlmnet}, RawData, AbstractVector{Float64}, AbstractVector{Float64}, Vector{Vector{Int64}}, Vector{Vector{Int64}}}" href="#MatrixLMnet.calc_mse-Tuple{AbstractVector{Mlmnet}, RawData, AbstractVector{Float64}, AbstractVector{Float64}, Vector{Vector{Int64}}, Vector{Vector{Int64}}}"><code>MatrixLMnet.calc_mse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    calc_mse(MLMNets::AbstractArray{Mlmnet,1}, data::RawData, 
              lambdas::AbstractArray{Float64,1}, 
              alphas::AbstractArray{Float64,1},
              rowFolds::Array{Array{Int64,1},1}, 
              colFolds::Array{Array{Int64,1},1})</code></pre><p>Calculates test MSE for each of the CV folds for each lambda. </p><p><strong>Arguments</strong></p><ul><li>MLMNets = 1d array of Mlmnet objects resulting from running cross validation</li><li>data = RawData object used to generate MLMNets</li><li>lambdas = 1d array of floats consisting of the total penalties in descending  order. If they are not in descending order, they will be sorted. </li><li>alphas = 1d array of floats consisting of the penalty ratio that  determines the mix of penalties between L1 and L2</li><li>rowFolds = 1d array of arrays containing booleans for the row folds</li><li>colFolds = 1d array of arrays containing booleans for the column folds</li></ul><p><strong>Value</strong></p><p>2d array of floats with dimensions equal to the number of lambdas by the  number of folds. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_helpers.jl#L119-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.calc_mse-Tuple{Mlmnet}" href="#MatrixLMnet.calc_mse-Tuple{Mlmnet}"><code>MatrixLMnet.calc_mse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    calc_mse(MLMNet::Mlmnet)</code></pre><p>Calculates test MSE for each pair of lambda-alpha. </p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object</li></ul><p><strong>Value</strong></p><p>Matrix of floats with dimensions equal to the number of lambdas by the number of alphas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/bic/mlmnet_bic_helpers.jl#L39-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.calc_prop_zero-Tuple{AbstractVector{Mlmnet}, AbstractVector{Float64}, AbstractVector{Float64}}" href="#MatrixLMnet.calc_prop_zero-Tuple{AbstractVector{Mlmnet}, AbstractVector{Float64}, AbstractVector{Float64}}"><code>MatrixLMnet.calc_prop_zero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_prop_zero(MLMNets::AbstractArray{Mlmnet,1}, 
                    lambdas::AbstractArray{Float64,1},
                    alphas::AbstractArray{Float64,1}; 
                    dig::Int64=12)</code></pre><p>Calculates proportion of zero interaction coefficients for each of the CV  folds for each lambda. </p><p><strong>Arguments</strong></p><ul><li>MLMNets = 1d array of Mlmnet objects resulting from running cross validation</li><li>lambdas = 1d array of floats consisting of lambda penalties used to  generate MLMNets</li></ul><p><strong>Keyword arguments</strong></p><ul><li>dig = integer; digits of precision for zero coefficients. Defaults to 12. </li></ul><p><strong>Value</strong></p><p>2d array of floats with dimensions equal to the number of lambdas by the  number of folds. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_helpers.jl#L187-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.calc_prop_zero-Tuple{Mlmnet}" href="#MatrixLMnet.calc_prop_zero-Tuple{Mlmnet}"><code>MatrixLMnet.calc_prop_zero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_prop_zero(MLMNet::Mlmnet; dig::Int64=12)</code></pre><p>Calculates proportion of zero interaction coefficients for each of the CV  folds for each lambda. </p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object </li></ul><p><strong>Keyword arguments</strong></p><ul><li>dig = integer; digits of precision for zero coefficients. Defaults to 12. </li></ul><p><strong>Value</strong></p><p>Matrix of floats with dimensions equal to the number of lambdas by the number of alphas. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/bic/mlmnet_bic_helpers.jl#L73-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.cd!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}" href="#MatrixLMnet.cd!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.cd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cd!(X::AbstractArray{Float64,2}, Y::AbstractArray{Float64,2}, 
         Z::AbstractArray{Float64,2}, lambda::Float64, alpha::Float64,
         B::AbstractArray{Float64,2}, 
         regXidx::AbstractArray{Int64,1}, 
         regZidx::AbstractArray{Int64,1}, reg::BitArray{2}, norms; 
         isVerbose::Bool=true, stepsize::Float64=0.01, 
         isRandom::Bool=true, thresh::Float64=10.0^(-7), 
         maxiter::Int=10^10)</code></pre><p>Performs coordinate descent using either random or cyclic updates. Does NOT  take advantage of the active set; see <code>cd_active!</code>. </p><p><strong>Arguments</strong></p><ul><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>lambda = lambda penalty, a floating scalar</li><li>alpha = parameter (ϵ[0, 1]) determining the mix of penalties between L1 and L2</li><li>B = 2d array of floats consisting of starting coefficient estimates</li><li>regXidx = 1d array of indices corresponding to regularized X covariates</li><li>regZidx = 1d array of indices corresponding to regularized Z covariates</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>stepsize = float; step size for updates  (irrelevant for coordinate descent). Defaults to <code>0.01</code>. </li><li>isRandom = boolean flag indicating whether to use random or cyclic updates.  Defaults to <code>true</code>. </li><li>thresh = threshold at which the coefficients are considered to have  converged, a floating scalar. Defaults to <code>10^(-7)</code>. </li><li>maxiter = maximum number of update iterations. Defaults to <code>10^10</code>. </li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p><p><strong>Some notes</strong></p><p>Convergence is determined as when the log ratio of the current and previous  criteria is less than the threshold <code>thresh</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/cd.jl#L321-L372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.cd_active!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}" href="#MatrixLMnet.cd_active!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.cd_active!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cd_active!(X::AbstractArray{Float64,2}, Y::AbstractArray{Float64,2}, 
                Z::AbstractArray{Float64,2}, lambda::Float64, alpha::Float64,
                B::AbstractArray{Float64,2}, 
                regXidx::AbstractArray{Int64,1}, 
                regZidx::AbstractArray{Int64,1}, reg::BitArray{2}, norms; 
                isVerbose::Bool=true, stepsize::Float64=0.01, 
                isRandom::Bool=true, thresh::Float64=10.0^(-7), 
                maxiter::Int=10^10)</code></pre><p>Performs coordinate descent, taking advantage of the active set, using either  random or cyclic updates. </p><p><strong>Arguments</strong></p><ul><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>lambda = lambda penalty, a floating scalar</li><li>alpha = parameter (ϵ[0, 1]) determining the mix of penalties between L1 and L2</li><li>B = 2d array of floats consisting of starting coefficient estimates</li><li>regXidx = 1d array of indices corresponding to regularized X covariates</li><li>regZidx = 1d array of indices corresponding to regularized Z covariates</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>stepsize = float; step size for updates  (irrelevant for coordinate descent). Defaults to <code>0.01</code>. </li><li>isRandom = boolean flag indicating whether to use random or cyclic updates.  Defaults to <code>true</code>. </li><li>thresh = threshold at which the coefficients are considered to have  converged, a floating scalar. Defaults to <code>10^(-7)</code>. </li><li>maxiter = maximum number of update iterations. Defaults to <code>10^10</code>. </li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p><p><strong>Some notes</strong></p><p>Convergence is determined as when the log ratio of the current and previous  criteria is less than the threshold <code>thresh</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/cd.jl#L431-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.coef-Tuple{Mlmnet, Float64, Float64}" href="#MatrixLMnet.coef-Tuple{Mlmnet, Float64, Float64}"><code>MatrixLMnet.coef</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coef(MLMNet::Mlmnet, lambda::Float64, alpha::Float64)</code></pre><p>Extract coefficients from Mlmnet object at a given lambda </p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object</li><li>lambda = lambda penalty to use, a floating scalar</li><li>alpha = alpha penalty to determine the mix of penalties between L1 and L2 a floating scalar</li></ul><p><strong>Value</strong></p><p>2d array of coefficients </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/predict.jl#L21-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.coef-Tuple{Mlmnet}" href="#MatrixLMnet.coef-Tuple{Mlmnet}"><code>MatrixLMnet.coef</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coef(MLMNet::Mlmnet)</code></pre><p>Extract all coefficients from Mlmnet object</p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object</li></ul><p><strong>Value</strong></p><p>3d array of coefficients </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/predict.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.coef_3d-Tuple{Mlmnet}" href="#MatrixLMnet.coef_3d-Tuple{Mlmnet}"><code>MatrixLMnet.coef_3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coef_3d(MLMNet::Mlmnet)</code></pre><p>Extract coefficients from Mlmnet object as a flattened 2d array</p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object</li></ul><p><strong>Value</strong></p><p>2d array of flattened coefficients, where each column corresponds to a  different lambda and alpha</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/predict.jl#L56-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.criterion-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractVector{Int64}}" href="#MatrixLMnet.criterion-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractVector{Int64}}"><code>MatrixLMnet.criterion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">criterion(B::AbstractArray{Float64,2}, 
               resid::AbstractArray{Float64,2}, 
               lambdaL1::Float64, lambdaL2::Float64, crit_denom::AbstractArray{Int64,1})</code></pre><p>Calculate the criterion for the Elastic-net penalty</p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of regularized coefficient estimates</li><li>resid = 2d array of floats consisting of the residuals</li><li>lambdaL1 = l1 penalty, a floating scalar</li><li>lambdaL2 = l2 penalty, a floating scalar</li><li>crit_denom = 1d array of 2 integers, the denominators of the criterion</li></ul><p><strong>Value</strong></p><p>A floating scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L25-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.findnotin-Tuple{AbstractVector{Int64}, AbstractVector{Int64}}" href="#MatrixLMnet.findnotin-Tuple{AbstractVector{Int64}, AbstractVector{Int64}}"><code>MatrixLMnet.findnotin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findnotin(a::AbstractArray{Int64,1}, b::AbstractArray{Int64,1})</code></pre><p>Returns elements of <code>b</code> that are not present in <code>a</code>. </p><p><strong>Arguments</strong></p><ul><li>a = 1d array of integers</li><li>b = 1d array of integers</li></ul><p><strong>Value</strong></p><p>1d array of integers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_helpers.jl#L90-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.fista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}" href="#MatrixLMnet.fista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.fista!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fista!(X::AbstractArray{Float64,2}, Y::AbstractArray{Float64,2}, 
            Z::AbstractArray{Float64,2}, 
            lambda::Float64, alpha::Float64,
            B::AbstractArray{Float64,2}, 
            regXidx::AbstractArray{Int64,1}, 
            regZidx::AbstractArray{Int64,1}, reg::BitArray{2}, norms; 
            isVerbose::Bool=true, stepsize::Float64=0.01, 
            thresh::Float64=10.0^(-7), maxiter::Int=10^10)</code></pre><p>Performs the Elastic-net version FISTA with fixed step size.</p><p><strong>Arguments</strong></p><ul><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>lambda = penalty parameter, a floating scalar</li><li>alpha = parameter (ϵ[0, 1]) determining the mix of penalties between L1 and L2</li><li>B = 2d array of floats consisting of starting coefficient estimates</li><li>regXidx = 1d array of indices corresponding to regularized X covariates</li><li>regZidx = 1d array of indices corresponding to regularized Z covariates</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>stepsize = float; step size for updates. Defaults to <code>0.01</code>. </li><li>thresh = threshold at which the coefficients are considered to have  converged, a floating scalar. Defaults to <code>10^(-7)</code>. </li><li>maxiter = maximum number of update iterations. Defaults to <code>10^10</code>. </li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p><p><strong>Some notes</strong></p><p>Convergence is determined as when the log ratio of the current and previous  criteria is less than the threshold <code>thresh</code>. </p><p>The default method for choosing the fixed step size for <code>fista!</code> is to use the  reciprocal of the product of the maximum eigenvalues of <code>X*transpose(X)</code>  and <code>Z*transpose(Z)</code>. This is computed by the <code>mlmnet</code> function when <code>fista!</code>  is passed into the <code>fun</code> argument and <code>setStepSize</code> is set to <code>true</code>. If  <code>setStepSize</code> is set to <code>false</code>, the value of the <code>stepsize</code> argument will be  used as the fixed step size. Note that obtaining the eigenvalues when <code>X</code>  and/or <code>Z</code> are very large may exceed computational limitations. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/fista.jl#L184-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.fista_bt!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}" href="#MatrixLMnet.fista_bt!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.fista_bt!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fista_bt!(X::AbstractArray{Float64,2}, Y::AbstractArray{Float64,2}, 
               Z::AbstractArray{Float64,2}, lambda::Float64, alpha::Float64,
               B::AbstractArray{Float64,2}, 
               regXidx::AbstractArray{Int64,1}, 
               regZidx::AbstractArray{Int64,1}, reg::BitArray{2}, norms; 
               isVerbose::Bool=true, stepsize::Float64=0.01, 
               gamma::Float64=0.5, thresh::Float64=10.0^(-7), 
               maxiter::Int=10^10)</code></pre><p>Performs FISTA with backtracking. </p><p><strong>Arguments</strong></p><ul><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>lambda = lambda penalty, a floating scalar</li><li>alpha = parameter (ϵ[0, 1]) determining the mix of penalties between L1 and L2</li><li>B = 2d array of floats consisting of starting coefficient estimates</li><li>regXidx = 1d array of indices corresponding to regularized X covariates</li><li>regZidx = 1d array of indices corresponding to regularized Z covariates</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>stepsize = float; step size for updates. Defaults to <code>0.01</code>. </li><li>gamma = float; multiplying factor for step size backtracking/line search.  Defaults to <code>0.5</code>. </li><li>thresh = threshold at which the coefficients are considered to have  converged, a floating scalar. Defaults to <code>10^(-7)</code>. </li><li>maxiter = maximum number of update iterations. Defaults to <code>10^10</code>. </li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p><p><strong>Some notes</strong></p><p>Convergence is determined as when the log ratio of the current and previous  criteria is less than the threshold <code>thresh</code>. </p><p>Specifying a good starting step size (<code>stepsize</code>) and multiplying factor  (<code>gamma</code>) in the <code>mlmnet</code> function when <code>fista_bt!</code> is passed into the <code>fun</code>  argument can be difficult. Shrinking the step size too gradually can result  in slow convergence. Doing so too quickly can cause the criterion to diverge.  We have found that setting <code>stepsize</code> to 0.01 often works well in practice;  choice of <code>gamma</code> appears to be less consequential. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/fista_bt.jl#L248-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.fitted-Tuple{Mlmnet, Float64, Float64}" href="#MatrixLMnet.fitted-Tuple{Mlmnet, Float64, Float64}"><code>MatrixLMnet.fitted</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fitted(MLMNet::Mlmnet, lambda::Float64, alpha::Float64)</code></pre><p>Calculate fitted values of an Mlmnet object, given a lambda </p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object</li><li>lambda = lambda penalty to use, a floating scalar</li><li>alpha = alpha penalty to determine the mix of penalties between L1 and L2 a floating scalar</li></ul><p><strong>Value</strong></p><p>2d array of fitted values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/predict.jl#L178-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.fitted-Tuple{Mlmnet}" href="#MatrixLMnet.fitted-Tuple{Mlmnet}"><code>MatrixLMnet.fitted</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fitted(MLMNet::Mlmnet)</code></pre><p>Calculate fitted values of an Mlmnet object</p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object</li></ul><p><strong>Value</strong></p><p>3d array of fitted values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/predict.jl#L201-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.get_func-Tuple{String}" href="#MatrixLMnet.get_func-Tuple{String}"><code>MatrixLMnet.get_func</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_func(method::String)</code></pre><p>Return actual module function name according to method name according to a dictionnary.</p><p><strong>Arguments</strong></p><ul><li>method = String describing selected method. The method can be &quot;ista&quot;,</li></ul><p>&quot;fista&quot;, &quot;fista_bt&quot; or &quot;admm&quot;.</p><p><strong>Value</strong></p><p>A function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L304-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.inner_update_cd!-Tuple{Int64, Int64, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, BitMatrix}" href="#MatrixLMnet.inner_update_cd!-Tuple{Int64, Int64, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, BitMatrix}"><code>MatrixLMnet.inner_update_cd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inner_update_cd!(i::Int64, j::Int64, B::AbstractArray{Float64,2}, 
                      resid::AbstractArray{Float64,2},
                      X::AbstractArray{Float64,2}, 
                      Z::AbstractArray{Float64,2}, 
                      norms::AbstractArray{Float64,2}, lambda::Float64, 
                      reg::BitArray{2})</code></pre><p>Updates a single coefficient estimate in place (to be called by  <code>update_cd_cyclic!</code>, <code>update_cd_random!</code>, <code>update_cd_active_cyclic!</code>, or  <code>update_cd_active_random!</code>) when <code>X</code> and <code>Z</code> are not standardized.</p><p><strong>Arguments</strong></p><ul><li>i = row index of the coefficient to update</li><li>j = column index of the coefficient to update</li><li>B = 2d array of floats consisting of coefficient estimates</li><li>resid = 2d array of floats consisting of the residuals</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient</li><li>lambda = lambda penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li></ul><p><strong>Value</strong></p><p>None; updates a coefficient in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/cd.jl#L54-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.inner_update_cd!-Tuple{Int64, Int64, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, BitMatrix}" href="#MatrixLMnet.inner_update_cd!-Tuple{Int64, Int64, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, BitMatrix}"><code>MatrixLMnet.inner_update_cd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inner_update_cd!(i::Int64, j::Int64, B::AbstractArray{Float64,2}, 
                      resid::AbstractArray{Float64,2}, 
                      X::AbstractArray{Float64,2}, 
                      Z::AbstractArray{Float64,2}, 
                      norms::Nothing, lambda::Float64, reg::BitArray{2})</code></pre><p>Updates a single coefficient estimate in place (to be called by  <code>update_cd_cyclic!</code>, <code>update_cd_random!</code>, <code>update_cd_active_cyclic!</code>, or  <code>update_cd_active_random!</code>) when <code>X</code> and <code>Z</code> are both standardized.</p><p><strong>Arguments</strong></p><ul><li>i = row index of the coefficient to update</li><li>j = column index of the coefficient to update</li><li>B = 2d array of floats consisting of coefficient estimates</li><li>resid = 2d array of floats consisting of the residuals</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = <code>nothing</code></li><li>lambda = lambda penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li></ul><p><strong>Value</strong></p><p>None; updates a coefficient in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/cd.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.ista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}" href="#MatrixLMnet.ista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractMatrix{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.ista!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istaNet!(X::AbstractArray{Float64,2}, Y::AbstractArray{Float64,2}, 
           Z::AbstractArray{Float64,2}, lambda::Float64, alpha::Float64, 
           B::AbstractArray{Float64,2}, 
           regXidx::AbstractArray{Int64,1}, 
           regZidx::AbstractArray{Int64,1}, reg::BitArray{2}, norms; 
           isVerbose::Bool=true, stepsize::Float64=0.01, 
           thresh::Float64=10.0^(-7), maxiter::Int=10^10)</code></pre><p>Performs the Elastic-net version ISTA with fixed step size.</p><p><strong>Arguments</strong></p><ul><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>lambda = penalty parameter, a floating scalar</li><li>alpha = parameter (ϵ[0, 1]) determining the mix of penalties between L1 and L2</li><li>B = 2d array of floats consisting of starting coefficient estimates</li><li>regXidx = 1d array of indices corresponding to regularized X covariates</li><li>regZidx = 1d array of indices corresponding to regularized Z covariates</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>stepsize = float; step size for updates. Defaults to <code>0.01</code>. </li><li>thresh = threshold at which the coefficients are considered to have  converged, a floating scalar. Defaults to <code>10^(-7)</code>. </li><li>maxiter = maximum number of update iterations. Defaults to <code>10^10</code>. </li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p><p><strong>Some notes</strong></p><p>Convergence is determined as when the log ratio of the current and previous  criteria is less than the threshold <code>thresh</code>. </p><p>The default method for choosing the fixed step size for <code>ista!</code> is to use the  reciprocal of the product of the maximum eigenvalues of <code>X*transpose(X)</code>  and <code>Z*transpose(Z)</code>. This is computed by the <code>mlmnet</code> function when <code>ista!</code>  is passed into the <code>fun</code> argument and <code>setStepSize</code> is set to <code>true</code>. If  <code>setStepSize</code> is set to <code>false</code>, the value of the <code>stepsize</code> argument will be  used as the fixed step size. Note that obtaining the eigenvalues when <code>X</code>  and/or <code>Z</code> are very large may exceed computational limitations. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/ista.jl#L140-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.lambda_min-Tuple{Mlmnet_cv}" href="#MatrixLMnet.lambda_min-Tuple{Mlmnet_cv}"><code>MatrixLMnet.lambda_min</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lambda_min(MLMNet_cv::Mlmnet_cv)</code></pre><p>Returns summary information for lambdas corresponding to the minimum average  test MSE across folds and the MSE one that is standard error greater. </p><p><strong>Arguments</strong></p><ul><li>MLMNet<em>cv = MLMNet</em>cv object</li></ul><p><strong>Value</strong></p><p>DataFrame from mlmnet<em>cv</em>summary restricted to the lambdas and alphas that correspond to  the minimum average test MSE across folds and the MSE that is one standard  error greater. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_summary.jl#L125-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.make_folds" href="#MatrixLMnet.make_folds"><code>MatrixLMnet.make_folds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_folds(n::Int64, k::Int64=10, k2::Int64=k)</code></pre><p>Generate <code>k</code> non-overlapping folds. </p><p><strong>Arguments</strong></p><ul><li>n = Total number of observations to split into folds. </li><li>k = Number of folds to create. Defaults to 10. If <code>k=1</code>, then all the data  (along this dimension) will be included in each fold. </li><li>k2 = If <code>k=1</code>, then all the data (along this dimension) will be included in  each fold. <code>k2</code> specifies how many folds there are. Defaults to <code>k</code>, which  is kind of silly, but there needs to be a placeholder. </li></ul><p><strong>Value</strong></p><p>1d array of length <code>k</code> of arrays of indices </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_helpers.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.make_folds_conds" href="#MatrixLMnet.make_folds_conds"><code>MatrixLMnet.make_folds_conds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_folds_conds(conds::AbstractArray{String,1}, 
                     k::Int64=10, prop::Float64=1/k)</code></pre><p>Generate <code>k</code> folds for a set of conditions, making sure each level of each  condition is represented in each fold. </p><p><strong>Arguments</strong></p><ul><li>conds = 1d array of conditions (strings)</li><li>k = Number of folds to create. Defaults to 10. </li><li>prop = Proportion of each condition level&#39;s replicates to include in each  fold. Defaults to 1/k. Each fold will contain at least one replicate of  each condition level. </li></ul><p><strong>Value</strong></p><p>1d array of length <code>k</code> of arrays of indices </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_helpers.jl#L34-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.minimize_rows-Tuple{Vector{CartesianIndex{2}}}" href="#MatrixLMnet.minimize_rows-Tuple{Vector{CartesianIndex{2}}}"><code>MatrixLMnet.minimize_rows</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimize_rows(indices::Vector{CartesianIndex{2}})</code></pre><p>Processes a vector of <code>CartesianIndex</code> objects representing positions in a 2D matrix  and returns a new vector of CartesianIndex objects. Each element in the resulting vector  should represent the smallest row index for each unique column index.</p><p><strong>Arguments</strong></p><ul><li>indices = 1d array of <code>CartesianIndex</code> objects representing positions in a 2D matrix</li></ul><p><strong>Value</strong></p><p>1d array of <code>CartesianIndex</code> objects representing the smallest row index for each unique  column index.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; input_indices = [CartesianIndex(1, 1), CartesianIndex(2, 1), CartesianIndex(3, 2), CartesianIndex(1, 2)]

julia&gt; output_indices = minimize_rows(input_indices)
2-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(1, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_helpers.jl#L242-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.mlmnet-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}}" href="#MatrixLMnet.mlmnet-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}}"><code>MatrixLMnet.mlmnet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mlmnet(data::RawData, 
            lambdas::AbstractArray{Float64,1}, alphas::AbstractArray{Float64,1};
            method::String = &quot;ista&quot;, 
            isNaive::Bool=false,
            addXIntercept::Bool=true, addZIntercept::Bool=true, 
            toXReg::BitArray{1}=trues(data.p), 
            toZReg::BitArray{1}=trues(data.q),     
            toXInterceptReg::Bool=false, toZInterceptReg::Bool=false, 
            toNormalize::Bool=true, isVerbose::Bool=true, 
            stepsize::Float64=0.01, setStepsize::Bool=true, 
            funArgs...)</code></pre><p>Centers and normalizes X and Z predictor matrices, calculates fixed step size, performs  the supplied method on two descending lists of lambdas and alphas (each for L1 and L2) using ``warm starts&#39;&#39;,  and backtransforms resulting coefficients, as is deemed necessary by the user  inputs.</p><p><strong>Arguments</strong></p><ul><li>data = RawData object</li><li>lambdas = 1d array of floats consisting of the total penalties in descending  order. If they are not in descending order, they will be sorted. </li><li>alphas = 1d array of floats consisting of the penalty ratio that  determines the mix of penalties between L1 and L2</li></ul><p><strong>Keyword arguments</strong></p><ul><li>methods = function name that applies the Elastic-net penalty estimate method; default is <code>ista</code>, and the other methods are <code>fista</code>, <code>fista_bt</code>, <code>admm</code> and <code>cd</code></li><li>isNaive = boolean flag indicating whether to solve the Naive or non-Naive  Elastic-net problem</li><li>addXIntercept = boolean flag indicating whether or not to include an <code>X</code>  intercept (row main effects). Defaults to <code>true</code>. </li><li>addZIntercept = boolean flag indicating whether or not to include a <code>Z</code>  intercept (column main effects). Defaults to <code>true</code>.</li><li>toXReg = 1d array of bit flags indicating whether or not to regularize each  of the <code>X</code> (row) effects. Defaults to 2d array of <code>true</code>s with length  equal to the number of <code>X</code> effects (equivalent to <code>data.p</code>). </li><li>toZReg = 1d array of bit flags indicating whether or not to regularize each  of the <code>Z</code> (column) effects. Defaults to 2d array of <code>true</code>s with length  equal to the number of <code>Z</code> effects (equivalent to <code>data.q</code>). </li><li>toXInterceptReg = boolean flag indicating whether or not to regularize the  <code>X</code> intercept Defaults to <code>false</code>. </li><li>toZInterceptReg = boolean flag indicating whether or not to regularize the  <code>Z</code> intercept. Defaults to <code>false</code>. </li><li>toNormalize = boolean flag indicating if the columns of <code>X</code> and <code>Z</code>  should be standardized (to mean 0, standard deviation 1). Defaults to <code>true</code>.</li><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>stepsize = float; step size for updates (irrelevant for coordinate  descent and when <code>setStepsize</code> is set to <code>true</code> for <code>ista!</code> and <code>fista!</code>).  Defaults to <code>0.01</code>. </li><li>setStepsize = boolean flag indicating whether the fixed step size should be  calculated (for <code>ista!</code> and <code>fista!</code>). Defaults to <code>true</code>.</li><li>funArgs = variable keyword arguments to be passed into <code>fun</code></li></ul><p><strong>Value</strong></p><p>An Mlmnet object</p><p><strong>Some notes</strong></p><p>The default method for choosing the fixed step size for <code>fista!</code> or <code>istaNet!</code>  is to use the reciprocal of the product of the maximum eigenvalues of  <code>X*transpose(X)</code> and <code>Z*transpose(Z)</code>. This is computed when <code>fista!</code> or  <code>ista!</code> is passed into the <code>fun</code> argument and <code>setStepsize</code> is set to <code>true</code>.  If <code>setStepsize</code> is set to <code>false</code>, the value of the <code>stepsize</code> argument will  be used as the fixed step size. Note that obtaining the eigenvalues when <code>X</code>  and/or <code>Z</code> are very large may exceed computational limitations. </p><p>Specifying a good starting step size (<code>stepsize</code>) and multiplying factor  (<code>gamma</code>) when <code>fista_bt!</code> is passed into the <code>fun</code> argument can be difficult.  Shrinking the step size too gradually can result in slow convergence. Doing so  too quickly can cause the criterion to diverge. We have found that setting  <code>stepsize</code> to 0.01 often works well in practice; choice of <code>gamma</code> appears to  be less consequential. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet.jl#L154-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.mlmnet_bic-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}}" href="#MatrixLMnet.mlmnet_bic-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}}"><code>MatrixLMnet.mlmnet_bic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mlmnet_bic(data::RawData, 
               lambdas::AbstractArray{Float64,1},
               alphas::AbstractArray{Float64,1}; 
               method::String=&quot;ista&quot;, isNaive::Bool=false,
               addXIntercept::Bool=true, addZIntercept::Bool=true, 
               toXReg::BitArray{1}=trues(size(get_X(data), 2)), 
               toZReg::BitArray{1}=trues(size(get_Z(data), 2)), 
               toXInterceptReg::Bool=false, toZInterceptReg::Bool=false, 
               toNormalize::Bool=true, isVerbose::Bool=true, 
               stepsize::Float64=0.01, setStepsize::Bool=true, 
               dig::Int64=12, funArgs...)</code></pre><p>Performs BIC validation for <code>mlmnet</code>. </p><p><strong>Arguments</strong></p><ul><li>data = RawData object</li><li>lambdas = 1d array of floats consisting of the total penalties in descending  order. If they are not in descending order, they will be sorted. </li><li>alphas = 1d array of floats consisting of the penalty ratio that  determines the mix of penalties between L1 and L2</li></ul><p><strong>Keyword arguments</strong></p><ul><li>methods = function name that applies the Elastic-net penalty estimate method; default is <code>ista</code>, and the other methods are <code>fista</code>, <code>fista_bt</code>, <code>admm</code> and <code>cd</code></li><li>isNaive = boolean flag indicating whether to solve the Naive or non-Naive  Elastic-net problem</li><li>addXIntercept = boolean flag indicating whether or not to include an <code>X</code>  intercept (row main effects). Defaults to <code>true</code>. </li><li>addZIntercept = boolean flag indicating whether or not to include a <code>Z</code>  intercept (column main effects). Defaults to <code>true</code>.</li><li>toXReg = 1d array of bit flags indicating whether or not to regularize each  of the <code>X</code> (row) effects. Defaults to 2d array of <code>true</code>s with length  equal to the number of <code>X</code> effects (equivalent to <code>data.p</code>). </li><li>toZReg = 1d array of bit flags indicating whether or not to regularize each  of the <code>Z</code> (column) effects. Defaults to 2d array of <code>true</code>s with length  equal to the number of <code>Z</code> effects (equivalent to <code>data.q</code>). </li><li>toXInterceptReg = boolean flag indicating whether or not to regularize the  <code>X</code> intercept Defaults to <code>false</code>. </li><li>toZInterceptReg = boolean flag indicating whether or not to regularize the  <code>Z</code> intercept. Defaults to <code>false</code>. </li><li>toNormalize = boolean flag indicating if the columns of <code>X</code> and <code>Z</code>  should be standardized (to mean 0, standard deviation 1). Defaults to <code>true</code>.</li><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>stepsize = float; step size for updates (irrelevant for coordinate  descent and when <code>setStepsize</code> is set to <code>true</code> for <code>ista!</code> and <code>fista!</code>).  Defaults to <code>0.01</code>. </li><li>setStepsize = boolean flag indicating whether the fixed step size should be  calculated (for <code>ista!</code> and <code>fista!</code>). Defaults to <code>true</code>.</li><li>dig = integer; digits of precision for zero coefficients. Defaults to 12. </li><li>funArgs = variable keyword arguments to be passed into <code>fun</code></li></ul><p><strong>Value</strong></p><p>An Mlmnet_bic object. </p><p><strong>Some notes</strong></p><p>This is the base <code>mlmnet_bic</code> function that all other variants call. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/bic/mlmnet_bic.jl#L29-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.mlmnet_bic_summary-Tuple{Mlmnet_bic}" href="#MatrixLMnet.mlmnet_bic_summary-Tuple{Mlmnet_bic}"><code>MatrixLMnet.mlmnet_bic_summary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mlmnet_bic_summary(MLMNet_bic::Mlmnet_bic)</code></pre><p>Summarizes results of BIC-validation by returning a table with: </p><ul><li>Lambdas used</li><li>MSE across folds for each lambda</li><li>Proportion of zero interaction coefficients across each pair  of lambda and alpha</li></ul><p><strong>Arguments</strong></p><ul><li>MLMNet<em>bic = Mlmnet</em>bic object</li></ul><p><strong>Value</strong></p><p>DataFrame summarizing BIC, MSE, proportion of zero interactions across each pair  of lambda and alpha. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/bic/mlmnet_bic_summary.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.mlmnet_cv-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}, Vector{Vector{Int64}}, Vector{Vector{Int64}}}" href="#MatrixLMnet.mlmnet_cv-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}, Vector{Vector{Int64}}, Vector{Vector{Int64}}}"><code>MatrixLMnet.mlmnet_cv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mlmnet_cvmlmnet_cv(data::RawData, 
               lambdas::AbstractArray{Float64,1},
               alphas::AbstractArray{Float64,1}, 
               rowFolds::Array{Array{Int64,1},1}, 
               colFolds::Array{Array{Int64,1},1}; 
               method::String=&quot;ista&quot;, isNaive::Bool=false,
               addXIntercept::Bool=true, addZIntercept::Bool=true, 
               toXReg::BitArray{1}=trues(size(get_X(data), 2)), 
               toZReg::BitArray{1}=trues(size(get_Z(data), 2)), 
               toXInterceptReg::Bool=false, toZInterceptReg::Bool=false, 
               toNormalize::Bool=true, isVerbose::Bool=true, 
               stepsize::Float64=0.01, setStepsize::Bool=true, 
               dig::Int64=12, funArgs...)</code></pre><p>Performs cross-validation for <code>mlmnet</code> using row and column folds from user  input. </p><p><strong>Arguments</strong></p><ul><li>data = RawData object</li><li>lambdas = 1d array of floats consisting of the total penalties in descending  order. If they are not in descending order, they will be sorted. </li><li>alphas = 1d array of floats consisting of the penalty ratio that  determines the mix of penalties between L1 and L2</li><li>rowFolds = 1d array of arrays (one array for each fold), each containing  the indices for a row fold; must be same length as colFolds. Can be  generated with a call to <code>make_folds</code>, which is based on <code>Kfold</code> from the  MLBase package. </li><li>colFolds = 1d array of arrays (one array for each fold), each containing  the indices for a column fold; must be same length as rowFolds. Can be  generated with a call to <code>make_folds</code>, which is based on <code>Kfold</code> from the  MLBase package</li></ul><p><strong>Keyword arguments</strong></p><ul><li>methods = function name that applies the Elastic-net penalty estimate method; default is <code>ista</code>, and the other methods are <code>fista</code>, <code>fista_bt</code>, <code>admm</code> and <code>cd</code></li><li>isNaive = boolean flag indicating whether to solve the Naive or non-Naive  Elastic-net problem</li><li>addXIntercept = boolean flag indicating whether or not to include an <code>X</code>  intercept (row main effects). Defaults to <code>true</code>. </li><li>addZIntercept = boolean flag indicating whether or not to include a <code>Z</code>  intercept (column main effects). Defaults to <code>true</code>.</li><li>toXReg = 1d array of bit flags indicating whether or not to regularize each  of the <code>X</code> (row) effects. Defaults to 2d array of <code>true</code>s with length  equal to the number of <code>X</code> effects (equivalent to <code>data.p</code>). </li><li>toZReg = 1d array of bit flags indicating whether or not to regularize each  of the <code>Z</code> (column) effects. Defaults to 2d array of <code>true</code>s with length  equal to the number of <code>Z</code> effects (equivalent to <code>data.q</code>). </li><li>toXInterceptReg = boolean flag indicating whether or not to regularize the  <code>X</code> intercept Defaults to <code>false</code>. </li><li>toZInterceptReg = boolean flag indicating whether or not to regularize the  <code>Z</code> intercept. Defaults to <code>false</code>. </li><li>toNormalize = boolean flag indicating if the columns of <code>X</code> and <code>Z</code>  should be standardized (to mean 0, standard deviation 1). Defaults to <code>true</code>.</li><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>stepsize = float; step size for updates (irrelevant for coordinate  descent and when <code>setStepsize</code> is set to <code>true</code> for <code>ista!</code> and <code>fista!</code>).  Defaults to <code>0.01</code>. </li><li>setStepsize = boolean flag indicating whether the fixed step size should be  calculated (for <code>ista!</code> and <code>fista!</code>). Defaults to <code>true</code>.</li><li>dig = integer; digits of precision for zero coefficients. Defaults to 12. </li><li>funArgs = variable keyword arguments to be passed into <code>fun</code></li></ul><p><strong>Value</strong></p><p>An Mlmnet_cv object. </p><p><strong>Some notes</strong></p><p>This is the base <code>mlmnet_cv</code> function that all other variants call. Folds  are computed in parallel when possible. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv.jl#L37-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.mlmnet_cv_summary-Tuple{Mlmnet_cv}" href="#MatrixLMnet.mlmnet_cv_summary-Tuple{Mlmnet_cv}"><code>MatrixLMnet.mlmnet_cv_summary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mlmnet_cv_summary(MLMNet_cv::Mlmnet_cv)</code></pre><p>Summarizes results of cross-validation by returning a table with: </p><ul><li>Lambdas used</li><li>Average MSE across folds for each lambda</li><li>Average proportion of zero interaction coefficeints across folds for each  lambda</li></ul><p><strong>Arguments</strong></p><ul><li>MLMNet<em>cv = MLMNet</em>cv object</li></ul><p><strong>Value</strong></p><p>DataFrame summarizing average MSE and proportion of zero interactions across  folds for each lambda. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_summary.jl#L72-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.mlmnet_pathwise-Tuple{Function, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}" href="#MatrixLMnet.mlmnet_pathwise-Tuple{Function, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Int64}, AbstractVector{Int64}, BitMatrix, Any}"><code>MatrixLMnet.mlmnet_pathwise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mlmnet_pathwise(fun::Function, X::AbstractArray{Float64,2}, 
                     Y::AbstractArray{Float64,2}, 
                     Z::AbstractArray{Float64,2}, 
                     lambdas::AbstractArray{Float64,1},
                     alphas::AbstractArray{Float64, 1},  
                     regXidx::AbstractArray{Int64,1}, 
                     regZidx::AbstractArray{Int64,1}, 
                     reg::BitArray{2}, norms; isVerbose::Bool=true, 
                     stepsize::Float64=0.01, funArgs...)</code></pre><p>Performs the supplied method on two descending lists of lambdas (for l1 and l2)  using ``warm starts&#39;&#39;. </p><p><strong>Arguments</strong></p><ul><li>fun = function that applies the Elastic-net pentalty estimate method</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>lambdas = 1d array of floats consisting of the total penalties in descending  order. If they are not in descending order, they will be sorted.</li><li>alphas = 1d array of floats consisting of the penalty ratio that  determines the mix of penalties between L1 and L2</li><li>regXidx = 1d array of indices corresponding to regularized X covariates</li><li>regZidx = 1d array of indices corresponding to regularized Z covariates</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>stepsize = float; step size for updates. Defaults to <code>0.01</code>. </li><li>funArgs = variable keyword arguments to be passed into <code>fun</code></li></ul><p><strong>Value</strong></p><p>A 4d array consisting of the coefficient estimates, with the different  lambdas and alphas along the first and second dimensions respectively</p><p><strong>Some notes</strong></p><p>Assumes that all necessary standardizations have been performed on X, Y, and  Z, including adding on intercepts. To be called by <code>mlmnet</code>, which performs  standardization and backtransforming. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet.jl#L21-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.mlmnet_perms-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}}" href="#MatrixLMnet.mlmnet_perms-Tuple{RawData, AbstractVector{Float64}, AbstractVector{Float64}}"><code>MatrixLMnet.mlmnet_perms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mlmnet_perms(data::RawData, 
                  lambdas::AbstractArray{Float64,1}, alphas::AbstractArray{Float64,1};
                  method::String = &quot;ista&quot;, isNaive::Bool=false, 
                  permFun::Function=shuffle_rows, 
                  addXIntercept::Bool=true, addZIntercept::Bool=true, 
                  toXReg::BitArray{1}=trues(data.p), 
                  toZReg::BitArray{1}=trues(data.q), 
                  toXInterceptReg::Bool=false, 
                  toZInterceptReg::Bool=false, 
                  toNormalize::Bool=true, isVerbose::Bool=true, 
                  stepsize::Float64=0.01, setStepsize=true, funArgs...)</code></pre><p>Permutes response matrix Y in RawData object and then calls the mlmnet core  function. </p><p><strong>Arguments</strong></p><ul><li>data = RawData object</li><li>lambdas = 1d array of floats consisting of the total penalties in descending  order. If they are not in descending order, they will be sorted. </li><li>alphas = 1d array of floats consisting of the penalty ratio that  determines the mix of penalties between L1 and L2 </li></ul><p><strong>Keyword arguments</strong></p><ul><li>methods = function name that applies the Elastic-net penalty estimate method; default is <code>ista</code>, and the other methods are <code>fista</code>, <code>fista_bt</code>, <code>admm</code> and <code>cd</code></li><li>isNaive = boolean flag indicating whether to solve the Naive or non-Naive  Elastic-net problem</li><li>permFun = function used to permute <code>Y</code>. Defaults to <code>shuffle_rows</code>  (shuffles rows of <code>Y</code>). </li><li>addXIntercept = boolean flag indicating whether or not to include an <code>X</code>  intercept (row main effects). Defaults to <code>true</code>. </li><li>addZIntercept = boolean flag indicating whether or not to include a <code>Z</code>  intercept (column main effects). Defaults to <code>true</code>.</li><li>toXReg = 1d array of bit flags indicating whether or not to regularize each  of the <code>X</code> (row) effects. Defaults to 2d array of <code>true</code>s with length  equal to the number of <code>X</code> effects (equivalent to <code>data.p</code>). </li><li>toZReg = 1d array of bit flags indicating whether or not to regularize each  of the <code>Z</code> (column) effects. Defaults to 2d array of <code>true</code>s with length  equal to the number of <code>Z</code> effects (equivalent to <code>data.q</code>). </li><li>toXInterceptReg = boolean flag indicating whether or not to regularize the  <code>X</code> intercept Defaults to <code>false</code>. </li><li>toZInterceptReg = boolean flag indicating whether or not to regularize the  <code>Z</code> intercept. Defaults to <code>false</code>. </li><li>toNormalize = boolean flag indicating if the columns of <code>X</code> and <code>Z</code>  should be standardized (to mean 0, standard deviation 1). Defaults to <code>true</code>.</li><li>isVerbose = boolean flag indicating whether or not to print messages.   Defaults to <code>true</code>. </li><li>setStepsize = boolean flag indicating whether the fixed step size should be  calculated (for <code>ista!</code> and <code>fista!</code>). Defaults to <code>true</code>.</li><li>stepsize = float; step size for updates (irrelevant for coordinate  descent and when <code>setStepsize</code> is set to <code>true</code> for <code>ista!</code> and <code>fista!</code>).  Defaults to <code>0.01</code>. </li><li>funArgs = variable keyword arguments to be passed into <code>fun</code></li></ul><p><strong>Value</strong></p><p>An MLMnet object</p><p><strong>Some notes</strong></p><p>The default method for choosing the fixed step size for <code>fista!</code> or <code>ista!</code>  is to use the reciprocal of the product of the maximum eigenvalues of  <code>X*transpose(X)</code> and <code>Z*transpose(Z)</code>. This is computed when <code>fista!</code> or  <code>ista!</code> is passed into the <code>fun</code> argument and <code>setStepsize</code> is set to <code>true</code>.  If <code>setStepsize</code> is set to <code>false</code>, the value of the <code>stepsize</code> argument will  be used as the fixed step size. Note that obtaining the eigenvalues when <code>X</code>  and/or <code>Z</code> are very large may exceed computational limitations. </p><p>Specifying a good starting step size (<code>stepsize</code>) and multiplying factor  (<code>gamma</code>) when <code>fista_bt!</code> is passed into the <code>fun</code> argument can be difficult.  Shrinking the step size too gradually can result in slow convergence. Doing so  too quickly can cause the criterion to diverge. We have found that setting  <code>stepsize</code> to 0.01 often works well in practice; choice of <code>gamma</code> appears to  be less consequential. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_perms.jl#L1-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.normalize!-Tuple{AbstractMatrix{Float64}, Bool}" href="#MatrixLMnet.normalize!-Tuple{AbstractMatrix{Float64}, Bool}"><code>MatrixLMnet.normalize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize!(A::AbstractArray{Float64,2}, hasIntercept::Bool)</code></pre><p>Centers and normalizes the columns of A in place</p><p><strong>Arguments</strong></p><ul><li>A = 2d array of floats</li><li>hasIntercept = boolean flag indicating whether the first column of A is the  intercept</li></ul><p><strong>Value</strong></p><p>Centers and normalizes A in place and returns 2d arrays of the column means and L2  norms of A before standardization. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/std_helpers.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.outer_update_fista_bt!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, Float64, BitMatrix, AbstractVector{Int64}, AbstractVector{Float64}, Float64}" href="#MatrixLMnet.outer_update_fista_bt!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, Float64, BitMatrix, AbstractVector{Int64}, AbstractVector{Float64}, Float64}"><code>MatrixLMnet.outer_update_fista_bt!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">outer_update_fista_bt!(B::AbstractArray{Float64,2}, 
                            B_prev::AbstractArray{Float64,2}, 
                            A::AbstractArray{Float64,2}, 
                            resid::AbstractArray{Float64,2}, 
                            resid_B::AbstractArray{Float64,2}, 
                            grad::AbstractArray{Float64,2}, 
                            X::AbstractArray{Float64,2}, 
                            Y::AbstractArray{Float64,2}, 
                            Z::AbstractArray{Float64,2}, 
                            norms, lambdaL1::Float64, lambdaL2::Float64,
                            reg::BitArray{2}, 
                            iter::AbstractArray{Int64,1}, 
                            stepsize::AbstractArray{Float64,1}, 
                            gamma::Float64)</code></pre><p>Uses backtracking to update step size for FISTA. </p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>B_prev = 2d array of floats consisting of coefficient estimates saved from  the previous iteration</li><li>A = 2d array of floats consisting of extrapolated coefficients </li><li>resid = 2d array of floats consisting of the residuals calculated from the  extrapolated coefficients</li><li>resid_B = 2d array of floats consisting of the residuals calculated from  the coefficient estimates</li><li>grad = 2d array of floats consisting of the gradient</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response observations</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li><li>lambdaL1 = l1 penalty, a floating scalar</li><li>lambdaL2 = l2 penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>iter = 1d array consisting of a single integer keeping track of how many  iterations have been computed</li><li>stepsize = 1d array consisting of a float; step size of updates</li><li>gamma = float; multiplying factor for step size backtracking/line search</li></ul><p><strong>Value</strong></p><p>None; updates coefficients and step size in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/fista_bt.jl#L133-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.predict" href="#MatrixLMnet.predict"><code>MatrixLMnet.predict</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict(MLMNet::Mlmnet, newPredictors::Predictors=MLMNet.data.predictors)</code></pre><p>Calculate new predictions based on Mlmnet object</p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object</li><li>newPredictors = Predictors object. Defaults to the data.predictors field  in the MLM object used to fit the model. </li></ul><p><strong>Value</strong></p><p>4d array of predicted values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/predict.jl#L145-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.predict" href="#MatrixLMnet.predict"><code>MatrixLMnet.predict</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict(MLMNet::Mlmnet, lambda::Float64, alpha::Float64,
             newPredictors::Predictors=MLMNet.data.predictors)</code></pre><p>Calculate new predictions based on Mlmnet object and given a lambda </p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object</li><li>lambda = lambda penalty to use, a floating scalar</li><li>alpha = alpha penalty to determine the mix of penalties between L1 and L2 a floating scalar</li><li>newPredictors = Predictors object. Defaults to the data.predictors field  in the MLM object used to fit the model. </li></ul><p><strong>Value</strong></p><p>2d array of predicted values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/predict.jl#L89-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.println_verbose" href="#MatrixLMnet.println_verbose"><code>MatrixLMnet.println_verbose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">println_verbose(x, isVerbose::Bool=true)</code></pre><p>Version of println that only prints when isVerbose flag is true</p><p><strong>Arguments</strong></p><ul><li>x = something that can be printed</li><li>isVerbose = boolean flag indicating whether or not to print messages.  Defaults to <code>true</code>. </li></ul><p><strong>Value</strong></p><p>None; prints to console</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.prox-NTuple{5, Float64}" href="#MatrixLMnet.prox-NTuple{5, Float64}"><code>MatrixLMnet.prox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prox(b::Float64, gradient::Float64, b2sign::Float64, 
          lambda::Float64, norm::Float64)</code></pre><p>Proximal (soft-thresholding) operator when step size is 1</p><p><strong>Arguments</strong></p><ul><li>b = coefficient to update, a float</li><li>gradient = gradient of b, a float</li><li>b2sign = sign of b + stepsize*gradient, a float</li><li>lambda = lambda penalty , a float</li><li>norm = norm corresponding to b, a float</li></ul><p><strong>Value</strong></p><p>A floating scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L197-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.prox-NTuple{6, Float64}" href="#MatrixLMnet.prox-NTuple{6, Float64}"><code>MatrixLMnet.prox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prox(b, gradient, b2sign, lambda, norm, stepsize)</code></pre><p>Proximal (soft-thresholding) operator</p><p><strong>Arguments</strong></p><ul><li>b = coefficient to update, a float</li><li>gradient = gradient of b, a float</li><li>b2sign = sign of b + stepsize*gradient, a float</li><li>lambda = lambda penalty , a float</li><li>norm = norm corresponding to b, a float</li><li>stepsize = step size to multiply updates, a float</li></ul><p><strong>Value</strong></p><p>A floating scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L144-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.prox-Tuple{Float64, Float64, Float64, Float64, Nothing, Float64}" href="#MatrixLMnet.prox-Tuple{Float64, Float64, Float64, Float64, Nothing, Float64}"><code>MatrixLMnet.prox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prox(b::Float64, gradient::Float64, b2sign::Float64, 
          lambda::Float64, norm::Nothing, stepsize::Float64)</code></pre><p>Proximal (soft-thresholding) operator when not incorporating the norms  (norms=1)</p><p><strong>Arguments</strong></p><ul><li>b = coefficient to update, a float</li><li>gradient = gradient of b, a float</li><li>b2sign = sign of b + stepsize*gradient, a float</li><li>lambda = lambda penalty , a float</li><li>norm = Nothing</li><li>stepsize = step size to multiply updates, a float</li></ul><p><strong>Value</strong></p><p>A floating scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L55-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.prox-Tuple{Float64, Float64, Float64, Float64, Nothing}" href="#MatrixLMnet.prox-Tuple{Float64, Float64, Float64, Float64, Nothing}"><code>MatrixLMnet.prox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prox(b, gradient, b2sign, lambda, norm)</code></pre><p>Proximal (soft-thresholding) operator when not incorporating the norms  (norms=1) and step size is 1</p><p><strong>Arguments</strong></p><ul><li>b = coefficient to update, a float</li><li>gradient = gradient of b, a float</li><li>b2sign = sign of b + stepsize*gradient, a float</li><li>lambda = lambda penalty , a float</li><li>norm = Nothing</li></ul><p><strong>Value</strong></p><p>A floating scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L111-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.prox_mat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, AbstractMatrix{Float64}, Float64}" href="#MatrixLMnet.prox_mat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, AbstractMatrix{Float64}, Float64}"><code>MatrixLMnet.prox_mat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prox_mat(b::AbstractArray{Float64,2}, b2sign::AbstractArray{Float64,2}, 
              lambda::Float64, norm::AbstractArray{Float64,2}, stepsize::Float64)</code></pre><p>Proximal (soft-thresholding) operator</p><p><strong>Arguments</strong></p><ul><li>b = coefficient to update, a float</li><li>b2sign = sign of b + stepsize*gradient, a float</li><li>lambda = lambda penalty , a float</li><li>norm = norm corresponding to b, a float</li><li>stepsize = step size to multiply updates, a float</li></ul><p><strong>Value</strong></p><p>A floating scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L171-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.prox_mat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, AbstractMatrix{Float64}}" href="#MatrixLMnet.prox_mat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, AbstractMatrix{Float64}}"><code>MatrixLMnet.prox_mat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prox_mat(b::AbstractArray{Float64,2}, b2sign::AbstractArray{Float64,2}, 
              lambda::Float64, norm::AbstractArray{Float64,2})</code></pre><p>Proximal (soft-thresholding) operator</p><p><strong>Arguments</strong></p><ul><li>b = coefficient to update, a float</li><li>b2sign = sign of b + stepsize*gradient, a float</li><li>lambda = lambda penalty , a float</li><li>norm = norm corresponding to b, a float</li></ul><p><strong>Value</strong></p><p>A floating scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L222-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.prox_mat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Nothing, Float64}" href="#MatrixLMnet.prox_mat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Nothing, Float64}"><code>MatrixLMnet.prox_mat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prox_mat(b::Float64, gradient::Float64, b2sign::Float64, 
          lambda::Float64, norm::Nothing, stepsize::Float64)</code></pre><p>Proximal (soft-thresholding) operator when not incorporating the norms  (norms=1)</p><p><strong>Arguments</strong></p><ul><li>b = coefficient to update, a float</li><li>gradient = gradient of b, a float</li><li>b2sign = sign of b + stepsize*gradient, a float</li><li>lambda = lambda penalty , a float</li><li>norm = Nothing</li><li>stepsize = step size to multiply updates, a float</li></ul><p><strong>Value</strong></p><p>A floating scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/mlmnet/mlmnet_helpers.jl#L83-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.resid" href="#MatrixLMnet.resid"><code>MatrixLMnet.resid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resid(MLMNet::Mlmnet, lambda::Float64, alpha::Float64, newData::RawData=MLMNet.data)</code></pre><p>Calculate residuals of an MLMNet object, given a lambda </p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object</li><li>lambda = lambda penalty to use, a floating scalar</li><li>alpha = alpha penalty to determine the mix of penalties between L1 and L2 a floating scalar</li><li>newData = RawData object. Defaults to the data field in the MLM object  used to fit the model. </li></ul><p><strong>Value</strong></p><p>2d array of residuals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/predict.jl#L221-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.resid" href="#MatrixLMnet.resid"><code>MatrixLMnet.resid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resid(MLMNet::Mlmnet, newData::RawData=MLMNet.data)</code></pre><p>Calculate residuals of an MLMNet object</p><p><strong>Arguments</strong></p><ul><li>MLMNet = Mlmnet object</li><li>newData = RawData object. Defaults to the data field in the MLM object  used to fit the model. </li></ul><p><strong>Value</strong></p><p>3d array of residuals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/utilities/predict.jl#L280-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_admm!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractVector{Int64}, AbstractVector{Int64}, AbstractVector{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, Float64}" href="#MatrixLMnet.update_admm!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, AbstractVector{Int64}, AbstractVector{Int64}, AbstractVector{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, Float64}"><code>MatrixLMnet.update_admm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_admm!update_admm!(B::AbstractArray{Float64,2}, 
                  B0::AbstractArray{Float64,2}, 
                  B2::AbstractArray{Float64,2}, 
                  resid::AbstractArray{Float64,2}, 
                  X::AbstractArray{Float64,2}, 
                  Y::AbstractArray{Float64,2}, 
                  Z::AbstractArray{Float64,2}, 
                  Qx::AbstractArray{Float64,2}, 
                  Qz::AbstractArray{Float64,2}, 
                  U::AbstractArray{Float64,2}, 
                  L::AbstractArray{Float64,2}, 
                  lambdaL1::Float64, lambdaL2::Float64, 
                  regXidx::AbstractArray{Int64,1}, 
                  regZidx::AbstractArray{Int64,1}, 
                  rho::AbstractArray{Float64,1}, 
                  r::AbstractArray{Float64,2}, 
                  s::AbstractArray{Float64,2}, 
                  tau_incr::Float64, tau_decr::Float64, mu::Float64)</code></pre><p>Updates coefficient estimates in place for each ADMM iteration. </p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates for L1 updates</li><li>B0 = 2d array of floats consisting of coefficient estimates for L2 updates</li><li>B2 = 2d array of floats consisting of coefficient estimates for dual updates</li><li>resid = 2d array of floats consisting of the residuals</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>Qx = 2d array of floats consisting of the eigenvectors of X</li><li>Qz = 2d array of floats consisting of the eigenvectors of Z</li><li>U = 2d array of floats consisting of the transformed Y matrix</li><li>L = 2d array of floats consisting of the kronecker product of the  eigenvalues of X and Z</li><li>lambdaL1 = l1 penalty, a floating scalar</li><li>lambdaL2 = l2 penalty, a floating scalar</li><li>regXidx = 1d array of indices corresponding to regularized X covariates</li><li>regZidx = 1d array of indices corresponding to regularized Z covariates</li><li>rho = float; parameter that controls ADMM tuning. </li><li>r = 2d array of floats consisting of the primal residuals. </li><li>s = 2d array of floats consisting of the dual residuals. </li><li>tau_incr = float; parameter that controls the factor at which rho increases.  Defaults to 2.0. </li><li>tau_decr = float; parameter that controls the factor at which rho decreases.  Defaults to 2.0. </li><li>mu = float; parameter that controls the factor at which the primal and dual  residuals should be within each other. Defaults to 10.0. </li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p><p><strong>Some notes</strong></p><p>Convergence is determined as when the log ratio of the current and previous  criteria is less than the threshold <code>thresh</code>. </p><p><code>rho</code> controls ADMM tuning and can be specified by the user. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/admm.jl#L49-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_cd_active_cyclic!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}}" href="#MatrixLMnet.update_cd_active_cyclic!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}}"><code>MatrixLMnet.update_cd_active_cyclic!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_cd_active_cyclic!(B::AbstractArray{Float64,2}, 
                              resid::AbstractArray{Float64,2},
                              X::AbstractArray{Float64,2}, 
                              Z::AbstractArray{Float64,2}, 
                              norms, lambda::Float64, reg::BitArray{2}, 
                              nonreg_idx::Tuple{AbstractArray{Int64,1},
                                                AbstractArray{Int64,1}}, 
                              active_idx::Tuple{AbstractArray{Int64,1},
                                                AbstractArray{Int64,1}})</code></pre><p>Cyclically updates active set of coefficients in place for each coordinate  descent iteration.</p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>resid = 2d array of floats consisting of the residuals</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li><li>lambda = lambda penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>nonreg_idx = tuple with the 2d indices of the non-regularized coefficients  as two 1d arrays of integers</li><li>active_idx = tuple with the 2d indices of the active coefficients as two 1d  arrays of integers</li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p><p><strong>Some notes</strong></p><p>Given that you pass in the indices for the non-regularized and active  (regularized) coefficients separately, this function can be further optimized  so that you don&#39;t check for regularization when updating each coefficient  with <code>inner_update!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/cd.jl#L196-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_cd_active_random!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}}" href="#MatrixLMnet.update_cd_active_random!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}}"><code>MatrixLMnet.update_cd_active_random!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_cd_active_random!(B::AbstractArray{Float64,2}, 
                              resid::AbstractArray{Float64,2},
                              X::AbstractArray{Float64,2}, 
                              Z::AbstractArray{Float64,2}, 
                              norms, lambda::Float64, reg::BitArray{2}, 
                              nonreg_idx::Tuple{AbstractArray{Int64,1},
                                                AbstractArray{Int64,1}}, 
                              active_idx::Tuple{AbstractArray{Int64,1},
                                                AbstractArray{Int64,1}})</code></pre><p>Randomly updates active set of coefficients in place for each coordinate  descent iteration.</p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>resid = 2d array of floats consisting of the residuals</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li><li>lambda = lambda penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>nonreg_idx = tuple with the 2d indices of the non-regularized coefficients  as two 1d arrays of integers</li><li>active_idx = tuple with the 2d indices of the active coefficients as two 1d  arrays of integers</li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/cd.jl#L262-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_cd_cyclic!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix}" href="#MatrixLMnet.update_cd_cyclic!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix}"><code>MatrixLMnet.update_cd_cyclic!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_cd_cyclic!(B::AbstractArray{Float64,2}, 
                       resid::AbstractArray{Float64,2}, 
                       X::AbstractArray{Float64,2}, 
                       Z::AbstractArray{Float64,2}, 
                       norms, lambda::Float64, reg::BitArray{2})</code></pre><p>Cyclically updates coefficients in place for each coordinate descent iteration.</p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>resid = 2d array of floats consisting of the residuals</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li><li>lambda = lambda penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/cd.jl#L110-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_cd_random!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix}" href="#MatrixLMnet.update_cd_random!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Any, Float64, BitMatrix}"><code>MatrixLMnet.update_cd_random!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_cd_random!(B::AbstractArray{Float64,2}, 
                       resid::AbstractArray{Float64,2}, 
                       X::AbstractArray{Float64,2}, 
                       Z::AbstractArray{Float64,2}, 
                       norms, lambda::Float64, reg::BitArray{2})</code></pre><p>Randomly updates coefficients in place for each coordinate descent iteration.</p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>resid = 2d array of floats consisting of the residuals</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient or <code>nothing</code></li><li>lambda = lambda penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/cd.jl#L151-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_fista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, BitMatrix, AbstractVector{Int64}, AbstractVector{Float64}}" href="#MatrixLMnet.update_fista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, BitMatrix, AbstractVector{Int64}, AbstractVector{Float64}}"><code>MatrixLMnet.update_fista!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_fista!(B::AbstractArray{Float64,2}, 
                   B_prev::AbstractArray{Float64,2}, 
                   A::AbstractArray{Float64,2}, 
                   resid::AbstractArray{Float64,2}, 
                   resid_B::AbstractArray{Float64,2}, 
                   grad::AbstractArray{Float64,2}, 
                   X::AbstractArray{Float64,2}, 
                   Y::AbstractArray{Float64,2}, 
                   Z::AbstractArray{Float64,2}, 
                   norms::AbstractArray{Float64,2}, 
                   lambdaL1::Float64, lambdaL2::Float64, 
                   reg::BitArray{2}, 
                   iter::AbstractArray{Int64,1}, 
                   stepsize::AbstractArray{Float64,1})</code></pre><p>Updates coefficient estimates in place for each FISTA iteration when <code>X</code> and  <code>Z</code> are not standardized. </p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>B_prev = 2d array of floats consisting of coefficient estimates saved from  the previous iteration</li><li>A = 2d array of floats consisting of extrapolated coefficients </li><li>resid = 2d array of floats consisting of the residuals calculated from the  extrapolated coefficients</li><li>resid_B = 2d array of floats consisting of the residuals calculated from  the coefficient estimates</li><li>grad = 2d array of floats consisting of the gradient</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response observations</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient</li><li>lambdaL1 = l1 penalty, a floating scalar</li><li>lambdaL2 = l2 penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>iter = 1d array consisting of a single integer keeping track of how many  iterations have been computed</li><li>stepsize = 1d array consisting of a float; step size of updates</li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/fista.jl#L91-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_fista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, Float64, BitMatrix, AbstractVector{Int64}, AbstractVector{Float64}}" href="#MatrixLMnet.update_fista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, Float64, BitMatrix, AbstractVector{Int64}, AbstractVector{Float64}}"><code>MatrixLMnet.update_fista!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_fista!(B::AbstractArray{Float64,2}, 
                   B_prev::AbstractArray{Float64,2}, 
                   A::AbstractArray{Float64,2}, 
                   resid::AbstractArray{Float64,2}, 
                   resid_B::AbstractArray{Float64,2}, 
                   grad::AbstractArray{Float64,2}, 
                   X::AbstractArray{Float64,2}, 
                   Y::AbstractArray{Float64,2}, 
                   Z::AbstractArray{Float64,2}, 
                   norms::Nothing, lambdaL1::Float64, lambdaL2::Float64,
                   reg::BitArray{2}, 
                   iter::AbstractArray{Int64,1}, 
                   stepsize::AbstractArray{Float64,1})</code></pre><p>Updates coefficient estimates in place for each FISTA iteration based on the Elastic-net silution, when <code>X</code> and <code>Z</code> are both standardized. </p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>B_prev = 2d array of floats consisting of coefficient estimates saved from  the previous iteration</li><li>A = 2d array of floats consisting of extrapolated coefficients </li><li>resid = 2d array of floats consisting of the residuals calculated from the  extrapolated coefficients</li><li>resid_B = 2d array of floats consisting of the residuals calculated from  the coefficient estimates</li><li>grad = 2d array of floats consisting of the gradient</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response observations</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = <code>nothing</code></li><li>lambdaL1 = l1 penalty, a floating scalar</li><li>lambdaL2 = l2 penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>iter = 1d array consisting of a single integer keeping track of how many  iterations have been computed</li><li>stepsize = 1d array consisting of a float; step size of updates</li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/fista.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_fista2!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, BitMatrix, AbstractVector{Float64}}" href="#MatrixLMnet.update_fista2!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, BitMatrix, AbstractVector{Float64}}"><code>MatrixLMnet.update_fista2!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_fista2!(B::AbstractArray{Float64,2}, 
                    A::AbstractArray{Float64,2}, 
                    resid_B::AbstractArray{Float64,2}, 
                    grad::AbstractArray{Float64,2}, 
                    X::AbstractArray{Float64,2}, 
                    Y::AbstractArray{Float64,2}, 
                    Z::AbstractArray{Float64,2}, 
                    norms::AbstractArray{Float64,2}, 
                    lambdaL1::Float64, lambdaL2::Float64, 
                    reg::BitArray{2}, 
                    stepsize::AbstractArray{Float64,1})</code></pre><p>Updates coefficient estimates in place for each FISTA iteration when <code>X</code> and  <code>Z</code> are not standardized, but without updating the extrapolated coefficients. </p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>A = 2d array of floats consisting of extrapolated coefficients </li><li>resid_B = 2d array of floats consisting of the residuals calculated from  the coefficient estimates</li><li>grad = 2d array of floats consisting of the gradient</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response observations</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient</li><li>lambda = lambda penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>stepsize = 1d array consisting of a float; step size of updates</li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/fista_bt.jl#L66-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_fista2!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, Float64, BitMatrix, AbstractVector{Float64}}" href="#MatrixLMnet.update_fista2!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, Float64, BitMatrix, AbstractVector{Float64}}"><code>MatrixLMnet.update_fista2!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_fista2!(B::AbstractArray{Float64,2}, 
                    A::AbstractArray{Float64,2}, 
                    resid_B::AbstractArray{Float64,2}, 
                    grad::AbstractArray{Float64,2}, 
                    X::AbstractArray{Float64,2}, 
                    Y::AbstractArray{Float64,2}, 
                    Z::AbstractArray{Float64,2}, 
                    norms::Nothing, lambdaL1::Float64, lambdaL2::Float64,
                    reg::BitArray{2}, 
                    stepsize::AbstractArray{Float64,1})</code></pre><p>Updates coefficient estimates in place for each FISTA iteration when <code>X</code> and  <code>Z</code> are both standardized, but without updating the extrapolated coefficients. </p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>A = 2d array of floats consisting of extrapolated coefficients </li><li>resid_B = 2d array of floats consisting of the residuals calculated from  the coefficient estimates</li><li>grad = 2d array of floats consisting of the gradient</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response observations</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = <code>nothing</code></li><li>lambdaL1 = l1 penalty, a floating scalar</li><li>lambdaL2 = l2 penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>stepsize = 1d array consisting of a float; step size of updates</li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/fista_bt.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_ista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, BitMatrix, AbstractVector{Float64}}" href="#MatrixLMnet.update_ista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Float64, Float64, BitMatrix, AbstractVector{Float64}}"><code>MatrixLMnet.update_ista!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_istaNet!(B::AbstractArray{Float64,2}, 
                  resid::AbstractArray{Float64,2}, 
                  grad::AbstractArray{Float64,2}, 
                  X::AbstractArray{Float64,2}, 
                  Y::AbstractArray{Float64,2}, 
                  Z::AbstractArray{Float64,2}, 
                  norms::AbstractArray{Float64,2}, 
                  lambdaL1::Float64, lambdaL2::Float64, reg::BitArray{2}, 
                  stepsize::AbstractArray{Float64,1})</code></pre><p>Updates coefficient estimates in place for each ISTA iteration based on the Elastic-net solution, when <code>X</code> and <code>Z</code> are not standardized. </p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>resid = 2d array of floats consisting of the residuals</li><li>grad = 2d array of floats consisting of the gradient</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response observations</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = 2d array of floats consisting of the norms corresponding to each  coefficient</li><li>lambdaL1 =  penalty, a floating scalar</li><li>lambdaL2 =  penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>stepsize = 1d array consisting of a float; step size of updates</li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/ista.jl#L70-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.update_ista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, Float64, BitMatrix, AbstractVector{Float64}}" href="#MatrixLMnet.update_ista!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Nothing, Float64, Float64, BitMatrix, AbstractVector{Float64}}"><code>MatrixLMnet.update_ista!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_istaNet!(B::AbstractArray{Float64,2}, 
                  resid::AbstractArray{Float64,2}, 
                  grad::AbstractArray{Float64,2}, 
                  X::AbstractArray{Float64,2}, 
                  Y::AbstractArray{Float64,2}, 
                  Z::AbstractArray{Float64,2}, 
                  norms::Nothing, lambdaL1::Float64, lambdaL2::Float64, 
                  reg::BitArray{2}, 
                  stepsize::AbstractArray{Float64,1})</code></pre><p>Updates coefficient estimates in place for each ISTA iteration based on the Elastic-net  solution, when <code>X</code> and <code>Z</code> are both standardized. </p><p><strong>Arguments</strong></p><ul><li>B = 2d array of floats consisting of coefficient estimates</li><li>resid = 2d array of floats consisting of the residuals</li><li>grad = 2d array of floats consisting of the gradient</li><li>X = 2d array of floats consisting of the row covariates, with all  categorical variables coded in appropriate contrasts</li><li>Y = 2d array of floats consisting of the multivariate response observations</li><li>Z = 2d array of floats consisting of the column covariates, with all  categorical variables coded in appropriate contrasts</li><li>norms = <code>nothing</code></li><li>lambdaL1 =  l1 penalty, a floating scalar</li><li>lambdaL1 =  l2 penalty, a floating scalar</li><li>reg = 2d array of bits, indicating whether or not to regularize each of the  coefficients</li><li>stepsize = 1d array consisting of a float; step size of updates</li></ul><p><strong>Value</strong></p><p>None; updates coefficients in place</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/methods/ista.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixLMnet.valid_reduce2" href="#MatrixLMnet.valid_reduce2"><code>MatrixLMnet.valid_reduce2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">valid_reduce2(A::Array{Float64,3}, fun::Function=mean)</code></pre><p>Reduce a 2d matrix across its columns using a given function, but ignoring  NaN, Inf, and -Inf. </p><p><strong>Arguments</strong></p><ul><li>A = 2d array of floats</li><li>fun = function with which to reduce across the columns of A</li></ul><p><strong>Value</strong></p><p>2d array of floats</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/MatrixLMnet.jl/blob/0273552d8b3456850c88ab44111e3a36128579d4/src/crossvalidation/mlmnet_cv_summary.jl#L1-L16">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MLMnet_Simulation/">« Getting Started</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 12 November 2025 20:28">Wednesday 12 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
